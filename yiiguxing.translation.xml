<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="584" />
    <option name="newTranslationDialogX" value="622" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Distribution information for a project that enables deployment of the site and artifacts to remote web servers and repositories respectively." />
      <item value="distribution Management" />
      <item value="The modules (sometimes called subprojects) to build as a part of this project. Each module listed is a relative path to the directory containing the module." />
      <item value="用于处理特定处理程序类和或处理程序方法中的异常的注释。" />
      <item value="the next adv" />
      <item value="This property specifies the annotation that the scanner will search for. The scanner will register all interfaces in the base package that also have the specified annotation. Note this can be combined with markerInterface. Params: annotationClass – annotation class" />
      <item value="This property specifies the annotation that the scanner will search for. &lt;p&gt; The scanner will register all interfaces in the base package that also have the specified annotation. &lt;p&gt; Note this can be combined with markerInterface. @param annotationClass annotation class" />
      <item value="Cannot enhance @Configuration bean definition 'mybatisConfig' since its singleton instance has been created too early" />
      <item value="Consider declaring such methods as 'static'" />
      <item value="The typical cause" />
      <item value="The commasemicolonspacetablinefeed-separated list of packages to scan for annotated components." />
      <item value="Controls which eligible types to exclude for component scanning." />
      <item value="Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected. Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations. Note: You may use placeholders in package paths, but only resolved against system properties (analogous to resource paths). A component scan results in new bean definitions being registered; Spring's PropertySourcesPlaceholderConfigurer will apply to those bean definitions just like to regular bean definitions, but it won't apply to the component scan settings themselves. See javadoc for org.springframework.context.annotation.ComponentScan for information on code-based alternatives to bootstrapping component-scanning." />
      <item value="Activates various annotations to be detected in bean classes: Spring's @Required and @Autowired, as well as JSR 250's @PostConstruct, @PreDestroy and @Resource (if available), JAX-WS's @WebServiceRef (if available), EJB 3's @EJB (if available), and JPA's @PersistenceContext and @PersistenceUnit (if available). Alternatively, you may choose to activate the individual BeanPostProcessors for those annotations. Note: This tag does not activate processing of Spring's @Transactional or EJB 3's @TransactionAttribute annotation. Consider the use of the &lt;tx:annotation-driven&gt; tag for that purpose. See javadoc for org.springframework.context.annotation.AnnotationConfigApplicationContext for information on code-based alternatives to bootstrapping annotation-driven support." />
      <item value="The traditional Spring default. No automagical wiring. Bean references must be defined in the XML file via the &lt;ref&gt; element (or &quot;ref&quot; attribute). We recommend this in most cases as it makes documentation more explicit." />
      <item value="Controls whether bean properties are &quot;autowired&quot;. This is an automagical process in which bean references don't need to be coded explicitly in the XML bean definition file, but rather the Spring container works out dependencies. The effective default is &quot;no&quot;." />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised. Note that explicit dependencies, i.e. &quot;property&quot; and &quot;constructor-arg&quot; elements, always override autowiring. Note: This attribute will not be inherited by child bean definitions. Hence, it needs to be specified per concrete bean definition. It can be shared through the 'default-autowire' attribute at the 'beans' level and potentially inherited from outer 'beans' defaults in case of nested 'beans' sections (e.g. with different profiles)." />
      <item value="Autowiring if there is exactly one bean of the property type in the container. If there is more than one, a fatal error is raised, and you cannot use byType autowiring for that bean. If there is none, nothing special happens." />
      <item value="Autowiring by property name. If a bean of class Cat exposes a &quot;dog&quot; property, Spring will try to set this to the value of the bean &quot;dog&quot; in the current container. If there is no matching bean by name, nothing special happens." />
      <item value="invalid" />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised. Note that explicit dependencies, i.e. &quot;property&quot; and &quot;constructor-arg&quot; elements, always override autowiring." />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised." />
      <item value="Alternative to class attribute for factory-method usage. If this is specified, no class attribute should be used. This must be set to the name of a bean in the current or ancestor factories that contains the relevant factory method. This allows the factory itself to be configured using Dependency Injection, and an instance (rather than static) method to be used." />
      <item value="Alternative to class attribute for factory-method usage" />
      <item value="Alternative" />
      <item value="This allows the factory itself to be configured using Dependency Injection, and an instance (rather than static) method to be used." />
      <item value="The scope of this bean: typically &quot;singleton&quot; (one shared instance, which will be returned by all calls to getBean with the given id), or &quot;prototype&quot; (independent instance resulting from each call to getBean). By default, a bean will be a singleton, unless the bean has a parent bean definition in which case it will inherit the parent's scope. Singletons are most commonly used, and are ideal for multi-threaded service objects. Further scopes, such as &quot;request&quot; or &quot;session&quot;, might be supported by extended bean factories (e.g. in a web environment). Inner bean definitions inherit the scope of their containing bean definition, unless explicitly specified: The inner bean will be a singleton if the containing bean is a singleton, and a prototype if the containing bean is a prototype, etc." />
      <item value="Indicates whether this bean is to be lazily initialized. If &quot;false&quot;, it will be instantiated on startup by bean factories that perform eager initialization of singletons. The effective default is &quot;false&quot;. Note: This attribute will not be inherited by child bean definitions. Hence, it needs to be specified per concrete bean definition. It can be shared through the 'default-lazy-init' attribute at the 'beans' level and potentially inherited from outer 'beans' defaults in case of nested 'beans' sections (e.g. with different profiles)." />
      <item value="our formatting needs). When the pattern attribute is specified, it takes precedence over both the style and ISO attribute. When the iso attribute is specified, it takes precedence over the style attribute. When no annotation attributes are specified, the default format applied is style-based with a style code of 'SS' (short date, short time). Time Zones Whenever the style or pattern attribute is used, the default time zone of the JVM will be used when formatting java.util.Date values. Whenever the iso attribute is used when formatting java.util.Date values, UTC will be used as the time zo" />
      <item value="less required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the Lice" />
      <item value="Helper class that simplifies Redis data access code. &lt;p&gt; Performs automatic serializationdeserialization between the given objects and the underlying binary data in the Redis store. By default, it uses Java serialization for its objects (through {@link JdkSerializationRedisSerializer} ). For String intensive operations consider the dedicated {@link StringRedisTemplate}. &lt;p&gt; The central method is execute, supporting Redis access code implementing the {@link RedisCallback} interface. It provides {@link RedisConnection} handling such that neither the {@link RedisCallback} implementation nor the calling code needs to explicitly care about retrievingclosing Redis connections, or handling Connection lifecycle exceptions. For typical single step actions, there are various convenience methods. &lt;p&gt; Once configured, this class is thread-safe. &lt;p&gt; Note that while the template is generified, it is up to the serializersdeserializers to properly convert the given Objects to and from binary data. &lt;p&gt; &lt;b&gt;This is the central class in Redis support&lt;b&gt;." />
      <item value="Spring Expression Language (SpEL) expression for computing the key dynamically. Default is &quot;&quot;, meaning all method parameters are considered as a key, unless a custom keyGenerator has been set. The SpEL expression evaluates against a dedicated context that provides the following meta-data: result for a reference to the result of the method invocation. For supported wrappers such as Optional, result refers to the actual object, not the wrapper root.method, root.target, and root.caches for references to the method, target object, and affected cache(s) respectively. Shortcuts for the method name (root.methodName) and target class (root.targetClass) are also available. Method arguments can be accessed by index. For instance the second argument can be accessed via root.args[1], p1 or a1. Arguments can also be accessed by name if that information is available." />
      <item value="MILLISECONDS" />
      <item value="The name of a factory method to use to create this object. Use constructor-arg elements to specify arguments to the factory method, if it takes arguments. Autowiring does not apply to factory methods. If the &quot;class&quot; attribute is present, the factory method will be a static method on the class specified by the &quot;class&quot; attribute on this bean definition. Often this will be the same class as that of the constructed object - for example, when the factory method is used as an alternative to a constructor. However, it may be on a different class. In that case, the created object will not be of the class specified in the &quot;class&quot; attribute. This is analogous to FactoryBean behavior. If the &quot;factory-bean&quot; attribute is present, the &quot;class&quot; attribute is not used, and the factory method will be an instance method on the object returned from a getBean call with the specified bean name. The factory bean may be defined as a singleton or a prototype. The factory method can have any number of arguments. Autowiring is not supported. Use indexed constructor-arg elements in conjunction with the factory-method attribute. Setter Injection can be used in conjunction with a factory method. Method Injection cannot, as the factory method returns an instance, which will be used when the container creates the bean." />
      <item value="The name of the custom destroy method to invoke on bean factory shutdown. The method must have no arguments, but may throw any exception. This is an alternative to implementing Spring's DisposableBean interface or the standard Java CloseableAutoCloseable interface, or marking a method with the PreDestroy annotation. Note: Only invoked on beans whose lifecycle is under the full control of the factory - which is always the case for singletons, but not guaranteed for any other scope." />
      <item value="Can be used to create one or more aliases illegal in an (XML) id. Multiple aliases can be separated by any number of spaces, commas, or semi-colons (or indeed any mixture of the three)." />
      <item value="o match for this type name: com.itheima.dao [Xlint:invalidAbsoluteTypeName] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602)" />
      <item value="Unsatisfied" />
      <item value="true" />
      <item value="initialized" />
      <item value="register the natives via the static initializer." />
      <item value="The name of a factory method to use to create this object. Use constructor-arg elements to specify arguments to the factory method, if it takes arguments. Autowiring does not apply to factory methods. If the &quot;class&quot; attribute is present, the factory method will be a static method on the class specified by the &quot;class&quot; attribute on this bean definition. Often this will be the same class as that of the constructed object - for example, when the factory method is used as an alternative to a constructor. However, it may be on a different class. In that case, the created object will not be of the class specified in the &quot;class&quot; attribute. This is analogous to FactoryBean behavior." />
      <item value="foo" />
      <item value="foot" />
      <item value="Singletons are most commonly used, and are ideal for multi-threaded&#10;&#9;service objects. Further scopes, such as &quot;request&quot; or &quot;session&quot;, might&#10;&#9;be supported by extended bean factories (e.g. in a web environment)." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="57" />
        <entry key="ENGLISH" value="58" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1638793442003" />
  </component>
  <component name="Settings">
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="13bb20da62b1370f " />
      </youdao-translate>
    </option>
  </component>
</application>