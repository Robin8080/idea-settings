<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="582" />
    <option name="newTranslationDialogX" value="622" />
    <option name="newTranslationDialogY" value="342" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Whether resources are filtered to replace tokens with parameterised values or not. The values are taken from the &amp;lt;code&amp;gt;properties&amp;lt;code&amp;gt; element and from the properties in the files listed in the &amp;lt;code&amp;gt;filters&amp;lt;code&amp;gt; element." />
      <item value="no custom rollback rules apply, the transaction will roll back on RuntimeException and Error but not on checked exceptions." />
      <item value="class it references to run the tests in that class instead of the runner built into JUnit. We added this feature late in development. While it seems powerful we expect the runner API to change as we learn how people really use it. Some of the classes that are currently internal will likely be refined and become public. For example, suites i" />
      <item value="Alternative to class attribute for factory-method usage. If this is specified, no class attribute should be used. This must be set to the name of a bean in the current or ancestor factories that contains the relevant factory method. This allows the factory itself to be configured using Dependency Injection, and an instance (rather than static) method to be used." />
      <item value="Can be used to create one or more aliases illegal in an (XML) id. Multiple aliases can be separated by any number of spaces, commas, or semi-colons (or indeed any mixture of the three)." />
      <item value="produces = &quot;textplain;charset=UTF-8&quot;" />
      <item value="present" />
      <item value="constructor, field, setter method, or config method as to be autowired by Spring's dependency injection facilities. This is an alternative to the JSR-330 javax.inject.Inject annotation, adding required-vs-optional semantics. Autowired Constructors" />
      <item value="Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations." />
      <item value="Intended to be used when no other attributes are needed, for example: @Be" />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised." />
      <item value="ontrols whether bean properties are &quot;autowired&quot;. This is an automagical process in which bean references don't need to be coded explicitly in the XML bean definition file, but rather the Spring container works out dependencies. The effective default is &quot;no&quot;" />
      <item value="Ambiguous" />
      <item value="did you specify the correct bean references as arguments" />
      <item value="pseudo" />
      <item value="Activates replacement of {...} placeholders by registering a PropertySourcesPlaceholderConfigurer within the application context. Properties will be resolved against the specified properties file or Properties object -- so called &quot;local properties&quot;, if any, and against the Spring Environment's current set of PropertySources." />
      <item value="The location of the properties file to resolve placeholders against, as a Spring resource location: a URL, a &quot;classpath:&quot; pseudo URL, or a relative file path. Multiple locations may be specified, separated by commas. If neither location nor properties-ref is specified, placeholders will be resolved against system properties." />
      <item value="The location of the properties file to resolve placeholders against, as a Spring resource location: a URL, a &quot;classpath:&quot; pseudo URL, or a relative file path. Multiple locations may be specified, separated by commas. If neither location nor properties-ref is specified, placeholders will be resolved against system properties" />
      <item value="Indicates the dependency is optional for use of this library. While the version of the dependency will be taken into account for dependency calculation if the library is used elsewhere, it will not be passed on transitively." />
      <item value="cans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected. Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations." />
      <item value="The name of a factory method to use to create this object. Use constructor-arg elements to specify arguments to the factory method, if it takes arguments. Autowiring does not apply to factory methods. If the &quot;class&quot; attribute is present, the factory method will be a static method on the class specified by the &quot;class&quot; attribute on this bean definition. Often this will be the same class as that of the constructed object - for example, when the factory method is used as an alternative to a constructor. However, it may be on a different class. In that case, the created object will not be of the class specified in the &quot;class&quot; attribute. This is analogous to FactoryBean behavior. If the &quot;factory-bean&quot; attribute is present, the &quot;class&quot; attribute is not used, and the factory method will be an instance method on the object returned from a getBean call with the specified bean name. The factory bean may be defined as a singleton or a prototype. The factory method can have any number of arguments. Autowiring is not supported. Use indexed constructor-arg elements in conjunction with the factory-method attribute. Setter Injection can be used in conjunction with a factory method. Method Injection cannot, as the factory method returns an instance, which will be used when the container creates the bean. ]]&gt;&lt;xsd:documentation&gt;" />
      <item value="The name of a factory method to use to create this object. Use constructor-arg elements to specify arguments to the factory method, if it takes arguments. Autowiring does not apply to factory methods. If the &quot;class&quot; attribute is present, the factory method will be a static method on the class specified by the &quot;class&quot; attribute on this bean definition. Often this will be the same class as that of the constructed object - for example, when the factory method is used as an alternative to a constructor. However, it may be on a different class. In that case, the created object will not be of the class specified in the &quot;class&quot; attribute. This is analogous to FactoryBean behavior. If the &quot;factory-bean&quot; attribute is present, the &quot;class&quot; attribute is not used, and the factory method will be an instance method on the object returned from a getBean call with the specified bean name. The factory bean may be defined as a singleton or a prototype. The factory method can have any number of arguments. Autowiring is not supported. Use indexed constructor-arg elements in conjunction with the factory-method attribute. Setter Injection can be used in conjunction with a factory method. Method Injection cannot, as the factory method returns an instance, which will be used when the container creates the bean." />
      <item value="The name of a factory method to use to create this object. Use constructor-arg elements to specify arguments to the factory method, if it takes arguments. Autowiring does not apply to factory methods. If the &quot;class&quot; attribute is present, the factory method will be a static method on the class specified by the &quot;class&quot; attribute on this bean definition. Often this will be the same class as that of the constructed object - for example, when the factory method is used as an alternative to a constructor. However, it may be on a different class. In that case, the created object will not be of the class specified in the &quot;class&quot; attribute. This is analogous to FactoryBean behavior. If the &quot;factory-bean&quot; attribute is present, the &quot;class&quot; attribute is not used, and the factory method will be an instance method on the object returned from a getBean call with the specified bean name. The factory bean may be defined as a singleton or a prototype. The factory method can have any number of arguments. Autowiring is not supported. Use indexed constructor-arg elements in conjunction with the factory-method attribute." />
      <item value="Flag to indicate if the run processes should be forked. Disabling forking will disable some features such as an agent, custom JVM arguments, devtools or specifying the working directory to use" />
      <item value="&gt;Flag to indicate if the run processes should be forked. Disabling forking will disable some features such as an agent, custom JVM arguments, devtools or specifying the working directory to use" />
      <item value="Use names and ensure unique to protect against duplicates" />
      <item value="Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter" />
      <item value="Describe the directory where the resources are stored. The path is relative to the POM." />
      <item value="This element describes all of the classpath resources such as properties files associated with a project. These resources are often included in the final package." />
      <item value="Distribution information for a project that enables deployment of the site and artifacts to remote web servers and repositories respectively." />
      <item value="distribution Management" />
      <item value="The modules (sometimes called subprojects) to build as a part of this project. Each module listed is a relative path to the directory containing the module." />
      <item value="用于处理特定处理程序类和或处理程序方法中的异常的注释。" />
      <item value="the next adv" />
      <item value="This property specifies the annotation that the scanner will search for. The scanner will register all interfaces in the base package that also have the specified annotation. Note this can be combined with markerInterface. Params: annotationClass – annotation class" />
      <item value="This property specifies the annotation that the scanner will search for. &lt;p&gt; The scanner will register all interfaces in the base package that also have the specified annotation. &lt;p&gt; Note this can be combined with markerInterface. @param annotationClass annotation class" />
      <item value="Cannot enhance @Configuration bean definition 'mybatisConfig' since its singleton instance has been created too early" />
      <item value="Consider declaring such methods as 'static'" />
      <item value="The typical cause" />
      <item value="The commasemicolonspacetablinefeed-separated list of packages to scan for annotated components." />
      <item value="Controls which eligible types to exclude for component scanning." />
      <item value="Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected. Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations. Note: You may use placeholders in package paths, but only resolved against system properties (analogous to resource paths). A component scan results in new bean definitions being registered; Spring's PropertySourcesPlaceholderConfigurer will apply to those bean definitions just like to regular bean definitions, but it won't apply to the component scan settings themselves. See javadoc for org.springframework.context.annotation.ComponentScan for information on code-based alternatives to bootstrapping component-scanning." />
      <item value="Activates various annotations to be detected in bean classes: Spring's @Required and @Autowired, as well as JSR 250's @PostConstruct, @PreDestroy and @Resource (if available), JAX-WS's @WebServiceRef (if available), EJB 3's @EJB (if available), and JPA's @PersistenceContext and @PersistenceUnit (if available). Alternatively, you may choose to activate the individual BeanPostProcessors for those annotations. Note: This tag does not activate processing of Spring's @Transactional or EJB 3's @TransactionAttribute annotation. Consider the use of the &lt;tx:annotation-driven&gt; tag for that purpose. See javadoc for org.springframework.context.annotation.AnnotationConfigApplicationContext for information on code-based alternatives to bootstrapping annotation-driven support." />
      <item value="The traditional Spring default. No automagical wiring. Bean references must be defined in the XML file via the &lt;ref&gt; element (or &quot;ref&quot; attribute). We recommend this in most cases as it makes documentation more explicit." />
      <item value="Controls whether bean properties are &quot;autowired&quot;. This is an automagical process in which bean references don't need to be coded explicitly in the XML bean definition file, but rather the Spring container works out dependencies. The effective default is &quot;no&quot;." />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised. Note that explicit dependencies, i.e. &quot;property&quot; and &quot;constructor-arg&quot; elements, always override autowiring. Note: This attribute will not be inherited by child bean definitions. Hence, it needs to be specified per concrete bean definition. It can be shared through the 'default-autowire' attribute at the 'beans' level and potentially inherited from outer 'beans' defaults in case of nested 'beans' sections (e.g. with different profiles)." />
      <item value="Autowiring if there is exactly one bean of the property type in the container. If there is more than one, a fatal error is raised, and you cannot use byType autowiring for that bean. If there is none, nothing special happens." />
      <item value="Autowiring by property name. If a bean of class Cat exposes a &quot;dog&quot; property, Spring will try to set this to the value of the bean &quot;dog&quot; in the current container. If there is no matching bean by name, nothing special happens." />
      <item value="invalid" />
      <item value="Analogous to &quot;byType&quot; for constructor arguments. If there is not exactly one bean of the constructor argument type in the bean factory, a fatal error is raised. Note that explicit dependencies, i.e. &quot;property&quot; and &quot;constructor-arg&quot; elements, always override autowiring." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="95" />
        <entry key="ENGLISH" value="96" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1642128541134" />
  </component>
  <component name="Settings">
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="13bb20da62b1370f " />
      </youdao-translate>
    </option>
  </component>
</application>